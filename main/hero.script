local GRAVITY = -10
local JUMP_SPEED_Y = 160
local JUMP_SPEED_X = 50
local RUN_SPEED = 20

go.property("direction", -1)

function init(self)
	self.velocity = vmath.vector3()
	self.pos = go.get_position()
	self.posLast = self.pos
	self.grounded = true
	self.groundedLast = self.grounded
	self.curAnim = ""

	sync_sprite_direction(self)
end

function update(self, dt)
	if not self.grounded then
		self.velocity = self.velocity + vmath.vector3(0, GRAVITY, 0)
		self.velocity.x = JUMP_SPEED_X * self.direction
	else
		self.velocity.x = RUN_SPEED * self.direction
	end

	self.posLast = self.pos
	self.pos = go.get_position()

	go.set_position(go.get_position() + self.velocity * dt)

	update_animation(self)

	self.groundedLast = self.grounded
	self.grounded = false

	--msg.post("@render:", "draw_line", {start_point = go.get_position(), end_point = go.get_position() + self.velocity, color = vmath.vector4(0, 0, 1, 0)})

	msg.post("main:/camera#script", "slope", { val = go.get_position().x })
end

function jump(self)
	if self.grounded then
		self.velocity.y = JUMP_SPEED_Y
		msg.post("#jump", "play_sound")
	end
end

function turn(self)
	if self.grounded then
		self.direction = -self.direction
		sync_sprite_direction(self)
		msg.post("#jump", "play_sound")
	end
end

function sync_sprite_direction(self)
	sprite.set_hflip("#sprite", self.direction > 0)
end

function update_animation(self)
	--if self.grounded and math.abs(self.pos.x - self.posLast.x) < 0.001 then
	--	set_animation(self, "idle")
	--	return
	--end

	if not (self.grounded == self.groundedLast) then
		if self.grounded then
			set_animation(self, "run")
			msg.post("main:/camera#script", "jump", { start = false })
		else
			set_animation(self, "jump")
			msg.post("main:/camera#script", "jump", { start = true })
		end
	end
end

function set_animation(self, anim_str)
	if not (self.curAnim == anim_str) then
		self.curAnim = anim_str
		msg.post("#sprite", "play_animation", { id = hash(anim_str) })
	end
end

function handle_contact(self, normal, distance)
	--msg.post("@render:", "draw_line", {start_point = go.get_position(), end_point = go.get_position() + normal * 20, color = vmath.vector4(1, 1, 0, 0)})

	if distance > 0 then
		go.set_position(go.get_position() + distance * normal)
	end

	if normal.y > 0.7 then
		self.grounded = true
	end

	local toground = vmath.dot(self.velocity, normal)
	if toground < 0 then
		self.velocity = self.velocity - toground * normal
	end
end

function on_message(self, message_id, message, sender)
	if message_id == hash("contact_point_response") then
		if message.group == hash("ground") then
			handle_contact(self, message.normal, message.distance)
		--elseif message.group == hash("dunger") then
		end
	elseif message_id == hash("jump") then
		jump(self)
	elseif message_id == hash("turn") then
		turn(self)
	elseif message_id == hash("exit_level") then
		go.animate("#sprite", "tint.w", go.PLAYBACK_ONCE_FORWARD, 0, go.EASING_LINEAR, 0.5)
	end
end
